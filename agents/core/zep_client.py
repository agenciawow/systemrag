"""
Cliente Zep para gerenciamento de memÃ³ria e sessÃµes

IntegraÃ§Ã£o com a API Zep para:
- Gerenciar usuÃ¡rios
- Gerenciar sessÃµes
- Buscar memÃ³ria e histÃ³rico de mensagens
- Adicionar novas mensagens
"""

import os
import logging
from typing import List, Dict, Any, Optional, Tuple
from dataclasses import dataclass
from datetime import datetime

# Zep official SDK imports
from zep_cloud.client import Zep
from zep_cloud.types import Message

logger = logging.getLogger(__name__)

@dataclass
class ZepMessage:
    """Estrutura de uma mensagem no Zep"""
    content: str
    role_type: str = "norole"  # pode ser "user", "assistant", ou "system"
    timestamp: Optional[str] = None

@dataclass
class ZepSession:
    """Estrutura de uma sessÃ£o no Zep"""
    session_id: str
    user_id: str
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

@dataclass
class ZepUser:
    """Estrutura de um usuÃ¡rio no Zep"""
    user_id: str
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

class ZepClient:
    """
    Cliente para integraÃ§Ã£o com a API Zep usando o SDK oficial
    
    Funcionalidades:
    - Gerenciamento de usuÃ¡rios
    - Gerenciamento de sessÃµes
    - Busca de memÃ³ria e histÃ³rico
    - AdiÃ§Ã£o de mensagens
    """
    
    def __init__(self, api_key: Optional[str] = None):
        """
        Inicializa o cliente Zep com o SDK oficial
        
        Args:
            api_key: Chave da API Zep (usa variÃ¡vel de ambiente se nÃ£o fornecida)
        """
        self.api_key = api_key or os.getenv("ZEP_API_KEY")
        if not self.api_key or not self.api_key.strip():
            raise ValueError("ZEP_API_KEY nÃ£o encontrada ou estÃ¡ vazia nas variÃ¡veis de ambiente")
        
        # Inicializar cliente oficial do Zep
        self.client = Zep(api_key=self.api_key)
        
        logger.info(f"Cliente Zep oficial inicializado")
    
    
    def get_user(self, user_id: str) -> Optional[ZepUser]:
        """
        Busca um usuÃ¡rio por ID usando o SDK oficial
        
        Args:
            user_id: ID do usuÃ¡rio
            
        Returns:
            ZepUser se encontrado, None caso contrÃ¡rio
        """
        logger.info(f"Buscando usuÃ¡rio: {user_id}")
        
        try:
            user = self.client.user.get(user_id=user_id)
            
            return ZepUser(
                user_id=user.user_id,
                created_at=str(user.created_at) if user.created_at else None,
                updated_at=str(user.updated_at) if user.updated_at else None
            )
        except Exception as e:
            logger.info(f"UsuÃ¡rio {user_id} nÃ£o encontrado: {e}")
            return None
    
    def create_user(self, user_id: str) -> ZepUser:
        """
        Cria um novo usuÃ¡rio usando o SDK oficial
        
        Args:
            user_id: ID do usuÃ¡rio a ser criado
            
        Returns:
            ZepUser criado
        """
        logger.info(f"Criando usuÃ¡rio: {user_id}")
        
        try:
            user = self.client.user.add(user_id=user_id)
            
            return ZepUser(
                user_id=user.user_id,
                created_at=str(user.created_at) if user.created_at else None,
                updated_at=str(user.updated_at) if user.updated_at else None
            )
        except Exception as e:
            # Se usuÃ¡rio jÃ¡ existe, tentar buscÃ¡-lo
            if "already exists" in str(e).lower():
                logger.info(f"UsuÃ¡rio {user_id} jÃ¡ existe, buscando...")
                existing_user = self.get_user(user_id)
                if existing_user:
                    return existing_user
            raise e
    
    def ensure_user_exists(self, user_id: str) -> ZepUser:
        """
        Garante que um usuÃ¡rio existe, criando se necessÃ¡rio
        
        Args:
            user_id: ID do usuÃ¡rio
            
        Returns:
            ZepUser existente ou criado
        """
        user = self.get_user(user_id)
        if user is None:
            logger.info(f"UsuÃ¡rio {user_id} nÃ£o existe, criando...")
            user = self.create_user(user_id)
        else:
            logger.info(f"UsuÃ¡rio {user_id} jÃ¡ existe")
        
        return user
    
    def get_session_memory(self, session_id: str, last_n: Optional[int] = None, min_rating: Optional[float] = None) -> Dict[str, Any]:
        """
        Busca a memÃ³ria de uma sessÃ£o usando o SDK oficial
        
        Args:
            session_id: ID da sessÃ£o
            last_n: NÃºmero de entradas mais recentes
            min_rating: Rating mÃ­nimo para filtrar fatos
            
        Returns:
            MemÃ³ria da sessÃ£o
        """
        logger.info(f"Buscando memÃ³ria da sessÃ£o: {session_id}")
        
        try:
            memory = self.client.memory.get(session_id=session_id, lastn=last_n, min_rating=min_rating)
            
            # Converter o objeto Memory para dict
            result = {"summary": "", "facts": [], "entities": []}
            
            if hasattr(memory, 'summary') and memory.summary:
                result["summary"] = memory.summary
            
            if hasattr(memory, 'facts') and memory.facts:
                result["facts"] = [fact.fact if hasattr(fact, 'fact') else str(fact) for fact in memory.facts]
            
            if hasattr(memory, 'entities') and memory.entities:
                result["entities"] = [entity.name if hasattr(entity, 'name') else str(entity) for entity in memory.entities]
            
            return result
            
        except Exception as e:
            logger.info(f"MemÃ³ria da sessÃ£o {session_id} nÃ£o encontrada: {e}")
            return {"summary": "", "facts": [], "entities": []}
    
    def get_session_messages(self, session_id: str, limit: int = 10, cursor: Optional[int] = None) -> List[Dict[str, Any]]:
        """
        Busca mensagens de uma sessÃ£o usando o SDK oficial
        
        Args:
            session_id: ID da sessÃ£o
            limit: Limite de mensagens a retornar
            cursor: Cursor para paginaÃ§Ã£o
            
        Returns:
            Lista de mensagens
        """
        logger.info(f"Buscando mensagens da sessÃ£o: {session_id} (limite: {limit})")
        
        try:
            messages_response = self.client.memory.get_session_messages(
                session_id=session_id,
                limit=limit,
                cursor=cursor
            )
            
            # Converter mensagens para formato dict compatÃ­vel
            messages = []
            for msg in messages_response.messages:
                message_dict = {
                    "content": msg.content,
                    "role_type": msg.role_type,
                    "created_at": str(msg.created_at) if msg.created_at else None,
                    "uuid": str(getattr(msg, 'uuid', None)) if hasattr(msg, 'uuid') and getattr(msg, 'uuid', None) else None
                }
                messages.append(message_dict)
            
            return messages
            
        except Exception as e:
            logger.info(f"Mensagens da sessÃ£o {session_id} nÃ£o encontradas: {e}")
            return []
    
    def add_memory_to_session(self, session_id: str, messages: List[ZepMessage], user_id: Optional[str] = None) -> Dict[str, Any]:
        """
        Adiciona memÃ³ria a uma sessÃ£o usando o SDK oficial
        
        Args:
            session_id: ID da sessÃ£o
            messages: Lista de mensagens a adicionar
            user_id: ID do usuÃ¡rio (necessÃ¡rio para criar sessÃ£o se nÃ£o existir)
            
        Returns:
            Resposta da API
        """
        logger.info(f"Adicionando {len(messages)} mensagens Ã  sessÃ£o: {session_id}")
        
        # Garantir que a sessÃ£o existe com o user_id correto
        if user_id:
            self._ensure_session_exists(session_id, user_id)
        
        # Converter mensagens para o formato SDK
        sdk_messages = []
        for msg in messages:
            sdk_message = Message(
                content=msg.content,
                role_type=msg.role_type
            )
            sdk_messages.append(sdk_message)
        
        # Adicionar mensagens usando o SDK
        result = self.client.memory.add(session_id=session_id, messages=sdk_messages)
        
        return {"success": True, "result": str(result)}
    
    def ensure_session_context(self, session_id: str, user_id: str) -> Tuple[str, List[Dict[str, Any]], bool]:
        """
        Garante que usuÃ¡rio e sessÃ£o existem e busca contexto completo
        
        Fluxo exato:
        1. Verificar se usuÃ¡rio existe â†’ se nÃ£o, criar
        2. Verificar se sessÃ£o existe (via Get Messages) â†’ se nÃ£o, serÃ¡ criada na primeira mensagem
        3. Buscar contexto: Get Session Memory + Get Messages for Session (limite 10)
        
        Args:
            session_id: ID da sessÃ£o
            user_id: ID do usuÃ¡rio
            
        Returns:
            Tupla (contexto_memoria, mensagens_recentes, is_new_session)
        """
        logger.info(f"ğŸ”„ Iniciando fluxo Zep para usuÃ¡rio {user_id}, sessÃ£o {session_id}")
        
        # 1. Verificar se usuÃ¡rio existe, se nÃ£o existir criar
        logger.info(f"ğŸ‘¤ Verificando usuÃ¡rio: {user_id}")
        user = self.get_user(user_id)
        if user is None:
            logger.info(f"ğŸ‘¤ UsuÃ¡rio {user_id} nÃ£o existe, criando...")
            user = self.create_user(user_id)
            logger.info(f"âœ… UsuÃ¡rio {user_id} criado")
        else:
            logger.info(f"âœ… UsuÃ¡rio {user_id} jÃ¡ existe")
        
        # 2. Verificar se sessÃ£o existe (tentando buscar mensagens)
        logger.info(f"ğŸ’¬ Verificando sessÃ£o: {session_id}")
        messages = self.get_session_messages(session_id, limit=10)
        is_new_session = len(messages) == 0
        
        if is_new_session:
            logger.info(f"ğŸ†• SessÃ£o {session_id} Ã© nova (0 mensagens)")
        else:
            logger.info(f"âœ… SessÃ£o {session_id} jÃ¡ existe ({len(messages)} mensagens)")
        
        # 3. Buscar memÃ³ria da sessÃ£o
        logger.info(f"ğŸ§  Buscando memÃ³ria da sessÃ£o: {session_id}")
        memory = self.get_session_memory(session_id, last_n=5)
        
        # Construir contexto de memÃ³ria
        memory_context = ""
        if memory and not is_new_session:
            # Tratar caso onde memory pode ser string ou objeto
            if isinstance(memory, str):
                memory_context += f"Resumo da conversa: {memory}\n\n"
            elif isinstance(memory, dict):
                summary = memory.get("summary", "")
                facts = memory.get("facts", [])
                
                if summary:
                    memory_context += f"Resumo da conversa: {summary}\n\n"
                
                if facts:
                    memory_context += "Fatos importantes:\n"
                    for fact in facts[:5]:  # Ãšltimos 5 fatos
                        if isinstance(fact, dict):
                            memory_context += f"- {fact.get('fact', '')}\n"
                        else:
                            memory_context += f"- {fact}\n"
                    memory_context += "\n"
        
        logger.info(f"ğŸ“Š Contexto preparado: {len(memory_context)} chars de memÃ³ria, {len(messages)} mensagens, nova_sessÃ£o={is_new_session}")
        
        return memory_context, messages, is_new_session
    
    def _ensure_session_exists(self, session_id: str, user_id: str) -> None:
        """
        Garante que uma sessÃ£o existe com o user_id correto
        
        Args:
            session_id: ID da sessÃ£o
            user_id: ID do usuÃ¡rio
        """
        try:
            # Tentar buscar a sessÃ£o para verificar se existe
            session = self.client.memory.get_session(session_id=session_id)
            logger.info(f"SessÃ£o {session_id} jÃ¡ existe para usuÃ¡rio {session.user_id}")
        except Exception:
            # Se nÃ£o existir, criar sessÃ£o explicitamente com user_id
            logger.info(f"Criando sessÃ£o {session_id} para usuÃ¡rio {user_id}")
            try:
                result = self.client.memory.add_session(
                    session_id=session_id,
                    user_id=user_id
                )
                logger.info(f"âœ… SessÃ£o {session_id} criada para usuÃ¡rio {user_id}: {result.session_id}")
            except Exception as e:
                logger.warning(f"Erro ao criar sessÃ£o {session_id}: {e} - serÃ¡ criada implicitamente")
    
    def save_conversation_turn(self, session_id: str, user_message: str, assistant_response: str, user_id: Optional[str] = None) -> None:
        """
        Salva uma volta de conversa (pergunta + resposta) na sessÃ£o
        
        Args:
            session_id: ID da sessÃ£o
            user_message: Mensagem do usuÃ¡rio
            assistant_response: Resposta do assistente
            user_id: ID do usuÃ¡rio (necessÃ¡rio para criar sessÃ£o se nÃ£o existir)
        """
        messages = [
            ZepMessage(content=user_message, role_type="user"),
            ZepMessage(content=assistant_response, role_type="assistant")
        ]
        
        try:
            self.add_memory_to_session(session_id, messages, user_id)
            logger.info(f"Conversa salva na sessÃ£o {session_id}")
        except Exception as e:
            logger.error(f"Erro ao salvar conversa na sessÃ£o {session_id}: {e}")
            # NÃ£o falha se nÃ£o conseguir salvar


# InstÃ¢ncia global do cliente
zep_client = None

def get_zep_client() -> ZepClient:
    """
    ObtÃ©m instÃ¢ncia global do cliente Zep
    
    Returns:
        InstÃ¢ncia do ZepClient
    """
    global zep_client
    
    if zep_client is None:
        try:
            zep_client = ZepClient()
            logger.info("Cliente Zep inicializado com sucesso")
        except ValueError as e:
            # Erro de configuraÃ§Ã£o - crÃ­tico
            logger.error(f"Erro de configuraÃ§Ã£o do Zep: {e}")
            raise e
        except Exception as e:
            # Outros erros - warning mas nÃ£o falha
            logger.warning(f"NÃ£o foi possÃ­vel inicializar cliente Zep: {e}")
            zep_client = None
    
    return zep_client

def is_zep_available() -> bool:
    """
    Verifica se o Zep estÃ¡ disponÃ­vel e configurado
    
    Returns:
        True se Zep estiver disponÃ­vel
    """
    return get_zep_client() is not None